// SPDX-License-Identifier: MIT
pragma solidity >=0.6.2 <0.9.0;

contract SimpleBank {
    uint8 private clientCount;
    mapping (address => uint) private balances;
    address public owner;

    // Log the event about a deposit being made by an address and its amount
    event LogDepositMade(address indexed accountAddress, uint amount);

    // Constructor is "payable" so it can receive the initial funding of 30,
    // required to reward the first 3 clients
    constructor() public payable {
        require(msg.value == 30 ether, "30 ether initial funding required");
        /* Set the owner to the creator of this contract */
        owner = msg.sender;
        clientCount = 0;
    }

    /// @notice Enroll a customer with the bank,
    /// giving the first 3 of them 10 ether as reward
    /// @return The balance of the user after enrolling
    function enroll() public returns (uint) {
        if (clientCount < 3) {
            clientCount++;
            balances[msg.sender] = 10 ether;
        }
        return balances[msg.sender];
    }

    /// @notice Deposit ether into bank, requires method is "payable"
    /// @return The balance of the user after the deposit is made
    function deposit() public payable returns (uint) {
        balances[msg.sender] += msg.value;
        emit LogDepositMade(msg.sender, msg.value);
        return balances[msg.sender];
    }

    /// @notice Withdraw ether from bank
    /// @return remainingBal The balance remaining for the user
    function withdraw(uint withdrawAmount) public returns (uint remainingBal) {
        // Check enough balance available, otherwise just return balance
        if (withdrawAmount <= balances[msg.sender]) {
            balances[msg.sender] -= withdrawAmount;
            payable(msg.sender).transfer(withdrawAmount);
        }
        return balances[msg.sender];
    }

    /// @notice Just reads balance of the account requesting, so "constant"
    /// @return The balance of the user
    function balance() public view returns (uint) {
        return balances[msg.sender];
    }

    /// @return The balance of the Simple Bank contract
    function depositsBalance() public view returns (uint) {
        return address(this).balance;
    }
}






Theory::

blockchain is a decentralized, secure, and transparent digital ledger technology that offers various advantages, including immutability, smart contracts, and the potential to disrupt numerous industries. It also faces challenges such as scalability, energy consumption, and regulatory concerns. Blockchain's adoption is growing, and it has the potential to reshape how we conduct transactions and manage data across various sectors.

smart contracts are self-executing contracts with predefined rules and conditions written in code. They automatically execute and enforce the terms of an agreement when specific conditions are met.

A block in a blockchain has a specific structure that includes several key components. Here's the typical structure of a block in a blockchain:

1. **Block Header**:
   - **Timestamp**: A timestamp indicating when the block was created.
   - **Previous Block Hash**: A reference to the cryptographic hash of the previous block in the blockchain. This link creates the chronological order of blocks.
   - **Merkle Root**: A cryptographic hash of all the transactions in the block. It's created by hashing transaction data in a tree structure (Merkle Tree) until a single hash remains, known as the Merkle Root.
   - **Nonce (Proof of Work Blockchains)**: A random number used in the mining process to satisfy specific criteria (e.g., a hash with a certain number of leading zeros).
   - **Difficulty Target (Proof of Work Blockchains)**: A value indicating the level of difficulty required for miners to find a valid nonce.

2. **Transaction Data**:
   - A list of transactions that occurred on the blockchain network. These transactions may include data, asset transfers, and smart contract interactions.

3. **Block Hash**:
   - A unique cryptographic hash generated by applying a hashing function (e.g., SHA-256 in Bitcoin) to the entire block's contents, including the block header and transaction data.
   - The block hash uniquely identifies the block within the blockchain and is a critical part of the block's integrity.

The structure of a block in a blockchain is consistent across most blockchain networks, but the specifics may vary depending on the blockchain's design and consensus mechanism. The block header is especially crucial for maintaining the integrity and order of blocks within the chain, while the transaction data contains the actual information about the transactions that have taken place. The block hash serves as a digital fingerprint, ensuring that the block is secure and tamper-proof.